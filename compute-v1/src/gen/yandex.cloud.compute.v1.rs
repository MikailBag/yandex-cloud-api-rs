/// A Disk resource. For more information, see \[Disks\](/docs/compute/concepts/disk).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Disk {
    /// ID of the disk.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// ID of the folder that the disk belongs to.
    #[prost(string, tag="2")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Name of the disk. 1-63 characters long.
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    /// Description of the disk. 0-256 characters long.
    #[prost(string, tag="5")]
    pub description: ::prost::alloc::string::String,
    /// Resource labels as `key:value` pairs. Maximum of 64 per resource.
    #[prost(map="string, string", tag="6")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// ID of the disk type.
    #[prost(string, tag="7")]
    pub type_id: ::prost::alloc::string::String,
    /// ID of the availability zone where the disk resides.
    #[prost(string, tag="8")]
    pub zone_id: ::prost::alloc::string::String,
    /// Size of the disk, specified in bytes.
    #[prost(int64, tag="9")]
    pub size: i64,
    /// Block size of the disk, specified in bytes.
    #[prost(int64, tag="15")]
    pub block_size: i64,
    /// License IDs that indicate which licenses are attached to this resource.
    /// License IDs are used to calculate additional charges for the use of the virtual machine.
    ///
    /// The correct license ID is generated by Yandex Cloud. IDs are inherited by new resources created from this resource.
    ///
    /// If you know the license IDs, specify them when you create the image.
    /// For example, if you create a disk image using a third-party utility and load it into Yandex Object Storage, the license IDs will be lost.
    /// You can specify them in the \[yandex.cloud.compute.v1.ImageService.Create\] request.
    #[prost(string, repeated, tag="10")]
    pub product_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Current status of the disk.
    #[prost(enumeration="disk::Status", tag="11")]
    pub status: i32,
    /// Array of instances to which the disk is attached.
    #[prost(string, repeated, tag="14")]
    pub instance_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Placement policy configuration.
    #[prost(message, optional, tag="16")]
    pub disk_placement_policy: ::core::option::Option<DiskPlacementPolicy>,
    #[prost(oneof="disk::Source", tags="12, 13")]
    pub source: ::core::option::Option<disk::Source>,
}
/// Nested message and enum types in `Disk`.
pub mod disk {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Disk is being created.
        Creating = 1,
        /// Disk is ready to use.
        Ready = 2,
        /// Disk encountered a problem and cannot operate.
        Error = 3,
        /// Disk is being deleted.
        Deleting = 4,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// ID of the image that was used for disk creation.
        #[prost(string, tag="12")]
        SourceImageId(::prost::alloc::string::String),
        /// ID of the snapshot that was used for disk creation.
        #[prost(string, tag="13")]
        SourceSnapshotId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskPlacementPolicy {
    /// Placement group ID.
    #[prost(string, tag="1")]
    pub placement_group_id: ::prost::alloc::string::String,
}
/// An Instance resource. For more information, see \[Instances\](/docs/compute/concepts/vm).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    /// ID of the instance.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// ID of the folder that the instance belongs to.
    #[prost(string, tag="2")]
    pub folder_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Name of the instance. 1-63 characters long.
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    /// Description of the instance. 0-256 characters long.
    #[prost(string, tag="5")]
    pub description: ::prost::alloc::string::String,
    /// Resource labels as `key:value` pairs. Maximum of 64 per resource.
    #[prost(map="string, string", tag="6")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// ID of the availability zone where the instance resides.
    #[prost(string, tag="7")]
    pub zone_id: ::prost::alloc::string::String,
    /// ID of the hardware platform configuration for the instance.
    #[prost(string, tag="8")]
    pub platform_id: ::prost::alloc::string::String,
    /// Computing resources of the instance such as the amount of memory and number of cores.
    #[prost(message, optional, tag="9")]
    pub resources: ::core::option::Option<Resources>,
    /// Status of the instance.
    #[prost(enumeration="instance::Status", tag="10")]
    pub status: i32,
    /// The metadata `key:value` pairs assigned to this instance. This includes custom metadata and predefined keys.
    ///
    /// For example, you may use the metadata in order to provide your public SSH key to the instance.
    /// For more information, see \[Metadata\](/docs/compute/concepts/vm-metadata).
    #[prost(map="string, string", tag="11")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Boot disk that is attached to the instance.
    #[prost(message, optional, tag="12")]
    pub boot_disk: ::core::option::Option<AttachedDisk>,
    /// Array of secondary disks that are attached to the instance.
    #[prost(message, repeated, tag="13")]
    pub secondary_disks: ::prost::alloc::vec::Vec<AttachedDisk>,
    /// Array of local disks that are attached to the instance.
    #[prost(message, repeated, tag="22")]
    pub local_disks: ::prost::alloc::vec::Vec<AttachedLocalDisk>,
    /// Array of filesystems that are attached to the instance.
    #[prost(message, repeated, tag="21")]
    pub filesystems: ::prost::alloc::vec::Vec<AttachedFilesystem>,
    /// Array of network interfaces that are attached to the instance.
    #[prost(message, repeated, tag="14")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    /// A domain name of the instance. FQDN is defined by the server
    /// in the format `<hostname>.<region_id>.internal` when the instance is created.
    /// If the hostname were not specified when the instance was created, FQDN would be `<id>.auto.internal`.
    ///
    /// output only
    #[prost(string, tag="16")]
    pub fqdn: ::prost::alloc::string::String,
    /// Scheduling policy configuration.
    #[prost(message, optional, tag="17")]
    pub scheduling_policy: ::core::option::Option<SchedulingPolicy>,
    /// ID of the service account to use for [authentication inside the instance](/docs/compute/operations/vm-connect/auth-inside-vm).
    /// To get the service account ID, use a \[yandex.cloud.iam.v1.ServiceAccountService.List\] request.
    #[prost(string, tag="18")]
    pub service_account_id: ::prost::alloc::string::String,
    /// Network Settings
    #[prost(message, optional, tag="19")]
    pub network_settings: ::core::option::Option<NetworkSettings>,
    /// Placement policy configuration.
    #[prost(message, optional, tag="20")]
    pub placement_policy: ::core::option::Option<PlacementPolicy>,
}
/// Nested message and enum types in `Instance`.
pub mod instance {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Instance is waiting for resources to be allocated.
        Provisioning = 1,
        /// Instance is running normally.
        Running = 2,
        /// Instance is being stopped.
        Stopping = 3,
        /// Instance stopped.
        Stopped = 4,
        /// Instance is being started.
        Starting = 5,
        /// Instance is being restarted.
        Restarting = 6,
        /// Instance is being updated.
        Updating = 7,
        /// Instance encountered a problem and cannot operate.
        Error = 8,
        /// Instance crashed and will be restarted automatically.
        Crashed = 9,
        /// Instance is being deleted.
        Deleting = 10,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resources {
    /// The amount of memory available to the instance, specified in bytes.
    #[prost(int64, tag="1")]
    pub memory: i64,
    /// The number of cores available to the instance.
    #[prost(int64, tag="2")]
    pub cores: i64,
    /// Baseline level of CPU performance with the ability to burst performance above that baseline level.
    /// This field sets baseline performance for each core.
    #[prost(int64, tag="3")]
    pub core_fraction: i64,
    /// The number of GPUs available to the instance.
    #[prost(int64, tag="4")]
    pub gpus: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedDisk {
    /// Access mode to the Disk resource.
    #[prost(enumeration="attached_disk::Mode", tag="1")]
    pub mode: i32,
    /// Serial number that is reflected into the /dev/disk/by-id/ tree
    /// of a Linux operating system running within the instance.
    ///
    /// This value can be used to reference the device for mounting, resizing, and so on, from within the instance.
    #[prost(string, tag="2")]
    pub device_name: ::prost::alloc::string::String,
    /// Specifies whether the disk will be auto-deleted when the instance is deleted.
    #[prost(bool, tag="3")]
    pub auto_delete: bool,
    /// ID of the disk that is attached to the instance.
    #[prost(string, tag="4")]
    pub disk_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AttachedDisk`.
pub mod attached_disk {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        /// Read-only access.
        ReadOnly = 1,
        /// Read/Write access.
        ReadWrite = 2,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedLocalDisk {
    /// Size of the disk, specified in bytes.
    #[prost(int64, tag="1")]
    pub size: i64,
    /// Serial number that is reflected into the /dev/disk/by-id/ tree
    /// of a Linux operating system running within the instance.
    ///
    /// This value can be used to reference the device for mounting, resizing, and so on, from within the instance.
    #[prost(string, tag="2")]
    pub device_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedFilesystem {
    /// Access mode to the filesystem.
    #[prost(enumeration="attached_filesystem::Mode", tag="1")]
    pub mode: i32,
    /// Name of the device representing the filesystem on the instance.
    ///
    /// The name should be used for referencing the filesystem from within the instance
    /// when it's being mounted, resized etc.
    #[prost(string, tag="2")]
    pub device_name: ::prost::alloc::string::String,
    /// ID of the filesystem that is attached to the instance.
    #[prost(string, tag="3")]
    pub filesystem_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AttachedFilesystem`.
pub mod attached_filesystem {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        /// Read-only access.
        ReadOnly = 1,
        /// Read/Write access.
        ReadWrite = 2,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterface {
    /// The index of the network interface, generated by the server, 0,1,2... etc.
    /// Currently only one network interface is supported per instance.
    #[prost(string, tag="1")]
    pub index: ::prost::alloc::string::String,
    /// MAC address that is assigned to the network interface.
    #[prost(string, tag="2")]
    pub mac_address: ::prost::alloc::string::String,
    /// ID of the subnet.
    #[prost(string, tag="3")]
    pub subnet_id: ::prost::alloc::string::String,
    /// Primary IPv4 address that is assigned to the instance for this network interface.
    #[prost(message, optional, tag="4")]
    pub primary_v4_address: ::core::option::Option<PrimaryAddress>,
    /// Primary IPv6 address that is assigned to the instance for this network interface. IPv6 not available yet.
    #[prost(message, optional, tag="5")]
    pub primary_v6_address: ::core::option::Option<PrimaryAddress>,
    /// ID's of security groups attached to the interface
    #[prost(string, repeated, tag="6")]
    pub security_group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrimaryAddress {
    /// An IPv4 internal network address that is assigned to the instance for this network interface.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// One-to-one NAT configuration. If missing, NAT has not been set up.
    #[prost(message, optional, tag="2")]
    pub one_to_one_nat: ::core::option::Option<OneToOneNat>,
    /// Internal DNS configuration
    #[prost(message, repeated, tag="3")]
    pub dns_records: ::prost::alloc::vec::Vec<DnsRecord>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneToOneNat {
    /// An external IP address associated with this instance.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// IP version for the external IP address.
    #[prost(enumeration="IpVersion", tag="2")]
    pub ip_version: i32,
    /// External DNS configuration
    #[prost(message, repeated, tag="3")]
    pub dns_records: ::prost::alloc::vec::Vec<DnsRecord>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsRecord {
    /// Name of the A/AAAA record as specified when creating the instance.
    /// Note that if `fqdn' has no trailing '.', it is specified relative to the zone (@see dns_zone_id).
    #[prost(string, tag="1")]
    pub fqdn: ::prost::alloc::string::String,
    /// DNS zone id for the record (optional, if not set, some private zone is used).
    #[prost(string, tag="2")]
    pub dns_zone_id: ::prost::alloc::string::String,
    /// DNS record ttl (optional, if not set, a reasonable default is used.)
    #[prost(int64, tag="3")]
    pub ttl: i64,
    /// When true, indicates there is a corresponding auto-created PTR DNS record.
    #[prost(bool, tag="4")]
    pub ptr: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedulingPolicy {
    /// True for short-lived compute instances. For more information, see [Preemptible VMs](/docs/compute/concepts/preemptible-vm).
    #[prost(bool, tag="1")]
    pub preemptible: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkSettings {
    /// Network Type
    #[prost(enumeration="network_settings::Type", tag="1")]
    pub r#type: i32,
}
/// Nested message and enum types in `NetworkSettings`.
pub mod network_settings {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        /// Standard network.
        Standard = 1,
        /// Software accelerated network.
        SoftwareAccelerated = 2,
        /// Hardware accelerated network (not available yet, reserved for future use).
        HardwareAccelerated = 3,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlacementPolicy {
    /// Placement group ID.
    #[prost(string, tag="1")]
    pub placement_group_id: ::prost::alloc::string::String,
    /// List of affinity rules. Scheduler will attempt to allocate instances according to order of rules.
    #[prost(message, repeated, tag="2")]
    pub host_affinity_rules: ::prost::alloc::vec::Vec<placement_policy::HostAffinityRule>,
}
/// Nested message and enum types in `PlacementPolicy`.
pub mod placement_policy {
    /// Affinitity definition
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HostAffinityRule {
        /// Affinity label or one of reserved values - 'yc.hostId', 'yc.hostGroupId'
        #[prost(string, tag="1")]
        pub key: ::prost::alloc::string::String,
        /// Include or exclude action
        #[prost(enumeration="host_affinity_rule::Operator", tag="2")]
        pub op: i32,
        /// Affinity value or host ID or host group ID
        #[prost(string, repeated, tag="3")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `HostAffinityRule`.
    pub mod host_affinity_rule {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            In = 1,
            NotIn = 2,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IpVersion {
    Unspecified = 0,
    /// IPv4 address, for example 192.0.2.235.
    Ipv4 = 1,
    /// IPv6 address. Not available yet.
    Ipv6 = 2,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
    /// ID of the Instance resource to return.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Defines which information about the Instance resource should be returned in the server response.
    #[prost(enumeration="InstanceView", tag="2")]
    pub view: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
    /// ID of the Folder to list instances in.
    /// To get the folder ID, use a \[yandex.cloud.resourcemanager.v1.FolderService.List\] request.
    #[prost(string, tag="1")]
    pub folder_id: ::prost::alloc::string::String,
    /// The maximum number of results per page to return. If the number of available
    /// results is larger than \[page_size\],
    /// the service returns a \[ListInstancesResponse.next_page_token\]
    /// that can be used to get the next page of results in subsequent list requests.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Page token. To get the next page of results,
    /// set \[page_token\] to the \[ListInstancesResponse.next_page_token\]
    /// returned by a previous list request.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter expression that filters resources listed in the response.
    /// The expression must specify:
    /// 1. The field name. Currently you can use filtering only on the \[Instance.name\] field.
    /// 2. An `=` operator.
    /// 3. The value in double quotes (`"`). Must be 3-63 characters long and match the regular expression `\[a-z]([-a-z0-9]{,61}[a-z0-9\])?`.
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesResponse {
    /// List of Instance resources.
    #[prost(message, repeated, tag="1")]
    pub instances: ::prost::alloc::vec::Vec<Instance>,
    /// This token allows you to get the next page of results for list requests. If the number of results
    /// is larger than \[ListInstancesRequest.page_size\], use
    /// the \[next_page_token\] as the value
    /// for the \[ListInstancesRequest.page_token\] query parameter
    /// in the next list request. Each subsequent list request will have its own
    /// \[next_page_token\] to continue paging through the results.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceRequest {
    /// ID of the folder to create an instance in.
    /// To get the folder ID, use a \[yandex.cloud.resourcemanager.v1.FolderService.List\] request.
    #[prost(string, tag="1")]
    pub folder_id: ::prost::alloc::string::String,
    /// Name of the instance.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Description of the instance.
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// Resource labels as `key:value` pairs.
    #[prost(map="string, string", tag="4")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// ID of the availability zone where the instance resides.
    /// To get a list of available zones, use the \[yandex.cloud.compute.v1.ZoneService.List\] request
    #[prost(string, tag="5")]
    pub zone_id: ::prost::alloc::string::String,
    /// ID of the hardware platform configuration for the instance.
    /// This field affects the available values in \[resources_spec\] field.
    ///
    /// Platforms allows you to create various types of instances: with a large amount of memory,
    /// with a large number of cores, with a burstable performance.
    /// For more information, see \[Platforms\](/docs/compute/concepts/vm-platforms).
    #[prost(string, tag="6")]
    pub platform_id: ::prost::alloc::string::String,
    /// Computing resources of the instance, such as the amount of memory and number of cores.
    /// To get a list of available values, see [Levels of core performance](/docs/compute/concepts/performance-levels).
    #[prost(message, optional, tag="7")]
    pub resources_spec: ::core::option::Option<ResourcesSpec>,
    /// The metadata `key:value` pairs that will be assigned to this instance. This includes custom metadata and predefined keys.
    /// The total size of all keys and values must be less than 512 KB.
    ///
    /// Values are free-form strings, and only have meaning as interpreted by the programs which configure the instance.
    /// The values must be 256 KB or less.
    ///
    /// For example, you may use the metadata in order to provide your public SSH key to the instance.
    /// For more information, see \[Metadata\](/docs/compute/concepts/vm-metadata).
    #[prost(map="string, string", tag="8")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Boot disk to attach to the instance.
    #[prost(message, optional, tag="9")]
    pub boot_disk_spec: ::core::option::Option<AttachedDiskSpec>,
    /// Array of secondary disks to attach to the instance.
    #[prost(message, repeated, tag="10")]
    pub secondary_disk_specs: ::prost::alloc::vec::Vec<AttachedDiskSpec>,
    /// Array of local disks to attach to the instance.
    #[prost(message, repeated, tag="18")]
    pub local_disk_specs: ::prost::alloc::vec::Vec<AttachedLocalDiskSpec>,
    /// Array of filesystems to attach to the instance.
    ///
    /// The filesystems must reside in the same availability zone as the instance.
    ///
    /// To use the instance with an attached filesystem, the latter must be mounted.
    /// For details, see \[documentation\](/docs/compute/operations/filesystem/attach-to-vm).
    #[prost(message, repeated, tag="17")]
    pub filesystem_specs: ::prost::alloc::vec::Vec<AttachedFilesystemSpec>,
    /// Network configuration for the instance. Specifies how the network interface is configured
    /// to interact with other services on the internal network and on the internet.
    /// Currently only one network interface is supported per instance.
    #[prost(message, repeated, tag="11")]
    pub network_interface_specs: ::prost::alloc::vec::Vec<NetworkInterfaceSpec>,
    /// Host name for the instance.
    /// This field is used to generate the \[yandex.cloud.compute.v1.Instance.fqdn\] value.
    /// The host name must be unique within the network and region.
    /// If not specified, the host name will be equal to \[yandex.cloud.compute.v1.Instance.id\] of the instance
    /// and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
    #[prost(string, tag="12")]
    pub hostname: ::prost::alloc::string::String,
    /// Scheduling policy configuration.
    #[prost(message, optional, tag="13")]
    pub scheduling_policy: ::core::option::Option<SchedulingPolicy>,
    /// ID of the service account to use for [authentication inside the instance](/docs/compute/operations/vm-connect/auth-inside-vm).
    /// To get the service account ID, use a \[yandex.cloud.iam.v1.ServiceAccountService.List\] request.
    #[prost(string, tag="14")]
    pub service_account_id: ::prost::alloc::string::String,
    /// Network settings.
    #[prost(message, optional, tag="15")]
    pub network_settings: ::core::option::Option<NetworkSettings>,
    /// Placement policy configuration.
    #[prost(message, optional, tag="16")]
    pub placement_policy: ::core::option::Option<PlacementPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceMetadata {
    /// ID of the instance that is being created.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceRequest {
    /// ID of the Instance resource to update.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Field mask that specifies which fields of the Instance resource are going to be updated.
    #[prost(message, optional, tag="2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Name of the instance.
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    /// Description of the instance.
    #[prost(string, tag="4")]
    pub description: ::prost::alloc::string::String,
    /// Resource labels as `key:value` pairs.
    ///
    /// Existing set of `labels` is completely replaced by the provided set.
    #[prost(map="string, string", tag="5")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// ID of the hardware platform configuration for the instance.
    /// This field affects the available values in \[resources_spec\] field.
    ///
    /// Platforms allows you to create various types of instances: with a large amount of memory,
    /// with a large number of cores, with a burstable performance.
    /// For more information, see \[Platforms\](/docs/compute/concepts/vm-platforms).
    #[prost(string, tag="6")]
    pub platform_id: ::prost::alloc::string::String,
    /// Computing resources of the instance, such as the amount of memory and number of cores.
    /// To get a list of available values, see [Levels of core performance](/docs/compute/concepts/performance-levels).
    #[prost(message, optional, tag="7")]
    pub resources_spec: ::core::option::Option<ResourcesSpec>,
    /// The metadata `key:value` pairs that will be assigned to this instance. This includes custom metadata and predefined keys.
    /// The total size of all keys and values must be less than 512 KB.
    ///
    /// Existing set of `metadata` is completely replaced by the provided set.
    ///
    /// Values are free-form strings, and only have meaning as interpreted by the programs which configure the instance.
    /// The values must be 256 KB or less.
    ///
    /// For example, you may use the metadata in order to provide your public SSH key to the instance.
    /// For more information, see \[Metadata\](/docs/compute/concepts/vm-metadata).
    #[prost(map="string, string", tag="8")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// ID of the service account to use for [authentication inside the instance](/docs/compute/operations/vm-connect/auth-inside-vm).
    /// To get the service account ID, use a \[yandex.cloud.iam.v1.ServiceAccountService.List\] request.
    #[prost(string, tag="9")]
    pub service_account_id: ::prost::alloc::string::String,
    /// Network settings.
    #[prost(message, optional, tag="10")]
    pub network_settings: ::core::option::Option<NetworkSettings>,
    /// Placement policy configuration.
    #[prost(message, optional, tag="11")]
    pub placement_policy: ::core::option::Option<PlacementPolicy>,
    /// Scheduling policy configuration.
    #[prost(message, optional, tag="12")]
    pub scheduling_policy: ::core::option::Option<SchedulingPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceMetadata {
    /// ID of the Instance resource that is being updated.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceRequest {
    /// ID of the instance to delete.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceMetadata {
    /// ID of the instance that is being deleted.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceMetadataRequest {
    /// ID of the instance that is being updated.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// List of keys to be deleted.
    #[prost(string, repeated, tag="2")]
    pub delete: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The metadata `key:value` pairs that will be added or updated to this instance.
    #[prost(map="string, string", tag="3")]
    pub upsert: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceMetadataMetadata {
    /// ID of the instance that is being updated.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceSerialPortOutputRequest {
    /// ID of the instance to return the serial port output for.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Serial port to retrieve data from. The default is 1.
    #[prost(int64, tag="2")]
    pub port: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceSerialPortOutputResponse {
    /// The contents of the serial port output, starting from the time when the instance
    /// started to boot.
    #[prost(string, tag="1")]
    pub contents: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopInstanceRequest {
    /// ID of the instance to stop.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopInstanceMetadata {
    /// ID of the instance that is being deleted.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartInstanceRequest {
    /// ID of the instance to start.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartInstanceMetadata {
    /// ID of the instance.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartInstanceRequest {
    /// ID of the instance to restart.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartInstanceMetadata {
    /// ID of the instance.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachInstanceDiskRequest {
    /// ID of the instance to attach the disk to.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Disk that should be attached.
    #[prost(message, optional, tag="2")]
    pub attached_disk_spec: ::core::option::Option<AttachedDiskSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachInstanceDiskMetadata {
    /// ID of the instance.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// ID of the disk.
    #[prost(string, tag="2")]
    pub disk_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachInstanceDiskRequest {
    /// ID of the instance to detach the disk from.
    /// To get the instance ID, use a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(oneof="detach_instance_disk_request::Disk", tags="2, 3")]
    pub disk: ::core::option::Option<detach_instance_disk_request::Disk>,
}
/// Nested message and enum types in `DetachInstanceDiskRequest`.
pub mod detach_instance_disk_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Disk {
        /// ID of the disk that should be detached.
        #[prost(string, tag="2")]
        DiskId(::prost::alloc::string::String),
        /// Serial number of the disk that should be detached. This value is reflected into the /dev/disk/by-id/ tree
        /// of a Linux operating system running within the instance.
        #[prost(string, tag="3")]
        DeviceName(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachInstanceDiskMetadata {
    /// ID of the instance.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// ID of the disk.
    #[prost(string, tag="2")]
    pub disk_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachInstanceFilesystemRequest {
    /// ID of the instance to attach the filesystem to.
    ///
    /// To get the instance ID, make a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Filesystem to attach to the instance.
    #[prost(message, optional, tag="2")]
    pub attached_filesystem_spec: ::core::option::Option<AttachedFilesystemSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachInstanceFilesystemMetadata {
    /// ID of the instance that the filesystem is being attached to.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// ID of the filesystem that is being attached to the instance.
    #[prost(string, tag="2")]
    pub filesystem_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachInstanceFilesystemRequest {
    /// ID of the instance to detach the filesystem from.
    ///
    /// To get the instance ID, make a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(oneof="detach_instance_filesystem_request::Filesystem", tags="2, 3")]
    pub filesystem: ::core::option::Option<detach_instance_filesystem_request::Filesystem>,
}
/// Nested message and enum types in `DetachInstanceFilesystemRequest`.
pub mod detach_instance_filesystem_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filesystem {
        /// ID of the filesystem that should be detached.
        #[prost(string, tag="2")]
        FilesystemId(::prost::alloc::string::String),
        /// Name of the device used for mounting the filesystem that should be detached.
        #[prost(string, tag="3")]
        DeviceName(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachInstanceFilesystemMetadata {
    /// ID of the instance that the filesystem is being detached from.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// ID of the filesystem that is being detached from the instance.
    #[prost(string, tag="2")]
    pub filesystem_id: ::prost::alloc::string::String,
}
/// Enables One-to-one NAT on the network interface.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddInstanceOneToOneNatRequest {
    /// ID of the instance to enable One-to-One NAT on.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// The index of the network interface to enable One-to-One NAT on.
    #[prost(string, tag="2")]
    pub network_interface_index: ::prost::alloc::string::String,
    /// The network address that is assigned to the instance for this network interface.
    ///
    /// optional
    #[prost(string, tag="3")]
    pub internal_address: ::prost::alloc::string::String,
    /// An external IP address configuration.
    /// If not specified, then this instance will have no external internet access.
    #[prost(message, optional, tag="4")]
    pub one_to_one_nat_spec: ::core::option::Option<OneToOneNatSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddInstanceOneToOneNatMetadata {
    /// ID of the instance.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveInstanceOneToOneNatRequest {
    /// ID of the instance to remove One-to-one NAT.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// The index of the network interface to remove One-to-One NAT from.
    #[prost(string, tag="2")]
    pub network_interface_index: ::prost::alloc::string::String,
    /// The network address that is assigned to the instance for this network interface.
    ///
    /// optional
    #[prost(string, tag="3")]
    pub internal_address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveInstanceOneToOneNatMetadata {
    /// ID of the instance.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceNetworkInterfaceRequest {
    /// ID of the network interface that is being updated.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// The index of the network interface to be updated.
    #[prost(string, tag="2")]
    pub network_interface_index: ::prost::alloc::string::String,
    /// Field mask that specifies which attributes of the instance should be updated.
    #[prost(message, optional, tag="3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// ID of the subnet.
    #[prost(string, tag="4")]
    pub subnet_id: ::prost::alloc::string::String,
    /// Primary IPv4 address that will be assigned to the instance for this network interface.
    #[prost(message, optional, tag="5")]
    pub primary_v4_address_spec: ::core::option::Option<PrimaryAddressSpec>,
    /// Primary IPv6 address that will be assigned to the instance for this network interface. IPv6 not available yet.
    #[prost(message, optional, tag="6")]
    pub primary_v6_address_spec: ::core::option::Option<PrimaryAddressSpec>,
    /// ID's of security groups attached to the interface.
    #[prost(string, repeated, tag="7")]
    pub security_group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceNetworkInterfaceMetadata {
    /// ID of the instant network interface that is being updated.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// The index of the network interface.
    #[prost(string, tag="2")]
    pub network_interface_index: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceOperationsRequest {
    /// ID of the Instance resource to list operations for.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// The maximum number of results per page to return. If the number of available
    /// results is larger than \[page_size\], the service returns a \[ListInstanceOperationsResponse.next_page_token\]
    /// that can be used to get the next page of results in subsequent list requests.
    #[prost(int64, tag="2")]
    pub page_size: i64,
    /// Page token. To get the next page of results, set \[page_token\] to the
    /// \[ListInstanceOperationsResponse.next_page_token\] returned by a previous list request.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceOperationsResponse {
    /// List of operations for the specified instance.
    #[prost(message, repeated, tag="1")]
    pub operations: ::prost::alloc::vec::Vec<super::super::operation::Operation>,
    /// This token allows you to get the next page of results for list requests. If the number of results
    /// is larger than \[ListInstanceOperationsRequest.page_size\], use the \[next_page_token\] as the value
    /// for the \[ListInstanceOperationsRequest.page_token\] query parameter in the next list request.
    /// Each subsequent list request will have its own \[next_page_token\] to continue paging through the results.
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcesSpec {
    /// The amount of memory available to the instance, specified in bytes.
    #[prost(int64, tag="1")]
    pub memory: i64,
    /// The number of cores available to the instance.
    #[prost(int64, tag="2")]
    pub cores: i64,
    /// Baseline level of CPU performance with the ability to burst performance above that baseline level.
    /// This field sets baseline performance for each core.
    ///
    /// For example, if you need only 5% of the CPU performance, you can set core_fraction=5.
    /// For more information, see [Levels of core performance](/docs/compute/concepts/performance-levels).
    #[prost(int64, tag="3")]
    pub core_fraction: i64,
    /// The number of GPUs available to the instance.
    #[prost(int64, tag="4")]
    pub gpus: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedDiskSpec {
    /// The mode in which to attach this disk.
    #[prost(enumeration="attached_disk_spec::Mode", tag="1")]
    pub mode: i32,
    /// Specifies a unique serial number of your choice that is reflected into the /dev/disk/by-id/ tree
    /// of a Linux operating system running within the instance.
    ///
    /// This value can be used to reference the device for mounting, resizing, and so on, from within the instance.
    /// If not specified, a random value will be generated.
    #[prost(string, tag="2")]
    pub device_name: ::prost::alloc::string::String,
    /// Specifies whether the disk will be auto-deleted when the instance is deleted.
    #[prost(bool, tag="3")]
    pub auto_delete: bool,
    #[prost(oneof="attached_disk_spec::Disk", tags="4, 5")]
    pub disk: ::core::option::Option<attached_disk_spec::Disk>,
}
/// Nested message and enum types in `AttachedDiskSpec`.
pub mod attached_disk_spec {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiskSpec {
        /// Name of the disk.
        #[prost(string, tag="1")]
        pub name: ::prost::alloc::string::String,
        /// Description of the disk.
        #[prost(string, tag="2")]
        pub description: ::prost::alloc::string::String,
        /// ID of the disk type.
        /// To get a list of available disk types, use the \[yandex.cloud.compute.v1.DiskTypeService.List\] request.
        #[prost(string, tag="3")]
        pub type_id: ::prost::alloc::string::String,
        /// Size of the disk, specified in bytes.
        #[prost(int64, tag="4")]
        pub size: i64,
        /// Block size of the disk, specified in bytes. The default is 4096.
        #[prost(int64, tag="8")]
        pub block_size: i64,
        /// Placement policy configuration.
        #[prost(message, optional, tag="7")]
        pub disk_placement_policy: ::core::option::Option<super::DiskPlacementPolicy>,
        #[prost(oneof="disk_spec::Source", tags="5, 6")]
        pub source: ::core::option::Option<disk_spec::Source>,
    }
    /// Nested message and enum types in `DiskSpec`.
    pub mod disk_spec {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Source {
            /// ID of the image to create the disk from.
            #[prost(string, tag="5")]
            ImageId(::prost::alloc::string::String),
            /// ID of the snapshot to restore the disk from.
            #[prost(string, tag="6")]
            SnapshotId(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        /// Read-only access.
        ReadOnly = 1,
        /// Read/Write access. Default value.
        ReadWrite = 2,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Disk {
        /// Disk specification.
        #[prost(message, tag="4")]
        DiskSpec(DiskSpec),
        /// ID of the disk that should be attached.
        #[prost(string, tag="5")]
        DiskId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedLocalDiskSpec {
    /// Size of the disk, specified in bytes.
    #[prost(int64, tag="1")]
    pub size: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedFilesystemSpec {
    /// Mode of access to the filesystem that should be attached.
    #[prost(enumeration="attached_filesystem_spec::Mode", tag="1")]
    pub mode: i32,
    /// Name of the device representing the filesystem on the instance.
    ///
    /// The name should be used for referencing the filesystem from within the instance
    /// when it's being mounted, resized etc.
    ///
    /// If not specified, a random value will be generated.
    #[prost(string, tag="2")]
    pub device_name: ::prost::alloc::string::String,
    /// ID of the filesystem that should be attached.
    #[prost(string, tag="3")]
    pub filesystem_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AttachedFilesystemSpec`.
pub mod attached_filesystem_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        /// Read-only access.
        ReadOnly = 1,
        /// Read/Write access. Default value.
        ReadWrite = 2,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterfaceSpec {
    /// ID of the subnet.
    #[prost(string, tag="1")]
    pub subnet_id: ::prost::alloc::string::String,
    /// Primary IPv4 address that will be assigned to the instance for this network interface.
    #[prost(message, optional, tag="2")]
    pub primary_v4_address_spec: ::core::option::Option<PrimaryAddressSpec>,
    /// Primary IPv6 address that will be assigned to the instance for this network interface. IPv6 not available yet.
    #[prost(message, optional, tag="3")]
    pub primary_v6_address_spec: ::core::option::Option<PrimaryAddressSpec>,
    /// ID's of security groups attached to the interface
    #[prost(string, repeated, tag="6")]
    pub security_group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrimaryAddressSpec {
    /// An IPv4 internal network address that is assigned to the instance for this network interface.
    /// If not specified by the user, an unused internal IP is assigned by the system.
    ///
    /// optional, manual set static internal IP
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// An external IP address configuration.
    /// If not specified, then this instance will have no external internet access.
    #[prost(message, optional, tag="2")]
    pub one_to_one_nat_spec: ::core::option::Option<OneToOneNatSpec>,
    /// Internal DNS configuration
    #[prost(message, repeated, tag="3")]
    pub dns_record_specs: ::prost::alloc::vec::Vec<DnsRecordSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneToOneNatSpec {
    /// External IP address version.
    ///
    ///only if address unspecified
    #[prost(enumeration="IpVersion", tag="1")]
    pub ip_version: i32,
    ///set static IP by value
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    /// External DNS configuration
    #[prost(message, repeated, tag="3")]
    pub dns_record_specs: ::prost::alloc::vec::Vec<DnsRecordSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsRecordSpec {
    /// FQDN (required)
    #[prost(string, tag="1")]
    pub fqdn: ::prost::alloc::string::String,
    /// DNS zone id (optional, if not set, private zone used)
    #[prost(string, tag="2")]
    pub dns_zone_id: ::prost::alloc::string::String,
    /// DNS record ttl, values in 0-86400 (optional)
    #[prost(int64, tag="3")]
    pub ttl: i64,
    /// When set to true, also create PTR DNS record (optional)
    #[prost(bool, tag="4")]
    pub ptr: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveInstanceRequest {
    /// ID of the instance to move.
    ///
    /// To get the instance ID, make a \[InstanceService.List\] request.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// ID of the folder to move the instance to.
    ///
    /// To get the folder ID, make a \[yandex.cloud.resourcemanager.v1.FolderService.List\] request.
    #[prost(string, tag="2")]
    pub destination_folder_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveInstanceMetadata {
    /// ID of the instance that is being moved.
    #[prost(string, tag="1")]
    pub instance_id: ::prost::alloc::string::String,
    /// ID of the folder that the instance is being moved from.
    #[prost(string, tag="2")]
    pub source_folder_id: ::prost::alloc::string::String,
    /// ID of the folder that the instance is being moved to.
    #[prost(string, tag="3")]
    pub destination_folder_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstanceView {
    /// Doesn't include the metadata of the instance in the server response.
    Basic = 0,
    /// Returns the metadata of the instance in the server response.
    Full = 1,
}
/// Generated client implementations.
pub mod instance_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// A set of methods for managing Instance resources.
    #[derive(Debug, Clone)]
    pub struct InstanceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl InstanceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> InstanceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Default + Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstanceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstanceServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with `gzip`.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_gzip(mut self) -> Self {
            self.inner = self.inner.send_gzip();
            self
        }
        /// Enable decompressing responses with `gzip`.
        #[must_use]
        pub fn accept_gzip(mut self) -> Self {
            self.inner = self.inner.accept_gzip();
            self
        }
        /// Returns the specified Instance resource.
        ///
        /// To get the list of available Instance resources, make a [List] request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceRequest>,
        ) -> Result<tonic::Response<super::Instance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Get",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Retrieves the list of Instance resources in the specified folder.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstancesRequest>,
        ) -> Result<tonic::Response<super::ListInstancesResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/List",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Creates an instance in the specified folder.
        /// Method starts an asynchronous operation that can be cancelled while it is in progress.
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInstanceRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Create",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Updates the specified instance.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInstanceRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Update",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Deletes the specified instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstanceRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Delete",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Updates the metadata of the specified instance.
        pub async fn update_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInstanceMetadataRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/UpdateMetadata",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Returns the serial port output of the specified Instance resource.
        pub async fn get_serial_port_output(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceSerialPortOutputRequest>,
        ) -> Result<
                tonic::Response<super::GetInstanceSerialPortOutputResponse>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/GetSerialPortOutput",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Stops the running instance.
        ///
        /// You can start the instance later using the [InstanceService.Start] method.
        pub async fn stop(
            &mut self,
            request: impl tonic::IntoRequest<super::StopInstanceRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Stop",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Starts the stopped instance.
        pub async fn start(
            &mut self,
            request: impl tonic::IntoRequest<super::StartInstanceRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Start",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Restarts the running instance.
        pub async fn restart(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartInstanceRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Restart",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Attaches the disk to the instance.
        pub async fn attach_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::AttachInstanceDiskRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/AttachDisk",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Detaches the disk from the instance.
        pub async fn detach_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::DetachInstanceDiskRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/DetachDisk",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Attaches the filesystem to the instance.
        ///
        /// The instance and the filesystem must reside in the same availability zone.
        ///
        /// To attach a filesystem, the instance must have a `STOPPED` status ([Instance.status]).
        /// To check the instance status, make a [InstanceService.Get] request.
        /// To stop the running instance, make a [InstanceService.Stop] request.
        ///
        /// To use the instance with an attached filesystem, the latter must be mounted.
        /// For details, see [documentation](/docs/compute/operations/filesystem/attach-to-vm).
        pub async fn attach_filesystem(
            &mut self,
            request: impl tonic::IntoRequest<super::AttachInstanceFilesystemRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/AttachFilesystem",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Detaches the filesystem from the instance.
        ///
        /// To detach a filesystem, the instance must have a `STOPPED` status ([Instance.status]).
        /// To check the instance status, make a [InstanceService.Get] request.
        /// To stop the running instance, make a [InstanceService.Stop] request.
        pub async fn detach_filesystem(
            &mut self,
            request: impl tonic::IntoRequest<super::DetachInstanceFilesystemRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/DetachFilesystem",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Enables One-to-one NAT on the network interface.
        pub async fn add_one_to_one_nat(
            &mut self,
            request: impl tonic::IntoRequest<super::AddInstanceOneToOneNatRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/AddOneToOneNat",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Removes One-to-one NAT from the network interface.
        pub async fn remove_one_to_one_nat(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveInstanceOneToOneNatRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/RemoveOneToOneNat",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Updates the specified instance network interface.
        pub async fn update_network_interface(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateInstanceNetworkInterfaceRequest,
            >,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/UpdateNetworkInterface",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Lists operations for the specified instance.
        pub async fn list_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstanceOperationsRequest>,
        ) -> Result<
                tonic::Response<super::ListInstanceOperationsResponse>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/ListOperations",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        /// Moves the specified instance to another folder of the same cloud.
        ///
        /// The instance must be stopped before moving. To stop the instance, make a [Stop] request.
        ///
        /// After moving, the instance will start recording its Yandex Monitoring default metrics to its new folder. Metrics
        /// that have been recorded to the source folder prior to moving will be retained.
        pub async fn r#move(
            &mut self,
            request: impl tonic::IntoRequest<super::MoveInstanceRequest>,
        ) -> Result<
                tonic::Response<super::super::super::operation::Operation>,
                tonic::Status,
            > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/yandex.cloud.compute.v1.InstanceService/Move",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
}
